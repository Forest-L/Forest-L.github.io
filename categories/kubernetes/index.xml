<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on 李林博客</title>
    <link>https://kubesphereio.com/categories/kubernetes/</link>
    <description>Recent content in Kubernetes on 李林博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>Copyright © 2008–2020</copyright>
    <lastBuildDate>Sat, 09 Jan 2021 17:44:37 +0800</lastBuildDate>
    
	<atom:link href="https://kubesphereio.com/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>K8s中定时Job设计模式</title>
      <link>https://kubesphereio.com/post/cronjob/</link>
      <pubDate>Sat, 09 Jan 2021 17:44:37 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/cronjob/</guid>
      <description>&lt;p&gt;定时Job模式通过添加时间维度扩展了批次Job模式，并允许由当时事件触发执行一个工作单元。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;在分布式系统和微服务的世界里，使用HTTP和轻量级消息传递的实时和事件驱动的应用交互是一个明显的趋势。然而，无论软件开发的最新趋势如何，Job调度有着悠久的历史，而且它仍然具有相关性。==定时Job通常用于自动化系统维护或管理任务==。它们也适用于需要定期执行特定任务的业务应用，这里的典型例子是通过文件传输进行业务对业务的集成，通过数据库轮询进行应用集成，发送新闻信邮件，以及清理和归档旧文件。&lt;/p&gt;
&lt;p&gt;对于系统维护而言，传统方法处理周期性Job是使用专门的调度软件或Cron。然而，对于简单的用例来说，专门的软件可能会很昂贵，而且在单一服务器上运行的Cron作业很难维护，而且是一个单一的故障点。这就是为什么，很多时候，开发人员倾向于实现既能处理调度方面的问题，又能处理需要执行的业务逻辑的解决方案。例如，在Java世界中，Quartz、Spring Batch等库以及带有ScheduledThreadPoolExecutor类的自定义实现都可以运行时间性任务。但与Cron类似，这种方法的主要难点是使调度能力具有弹性和高可用，从而导致资源的高消耗。另外，采用这种方法，基于时间的任务调度器是应用程序的一部分，要使调度器高度可用，整个应用程序必须高度可用。通常情况下，这涉及到运行多个应用实例，同时要保证只有一个实例是活跃的，并调度作业&amp;ndash;这就涉及到领导者选举和其他分布式系统的挑战。&lt;/p&gt;
&lt;p&gt;最后，一个简单的服务，每天要复制几个文件一次，最后可能需要多个节点，分布式的领导选举机制等等。Kubernetes CronJob的实现解决了这些问题，它允许使用著名的Cron格式对Job资源进行调度，让开发者只专注于实现要执行的工作，而不是时间调度方面。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;在Batch Job中，我们看到了Kubernetes Jobs的用例和功能。所有这些也适用于本章，因为CronJob基元建立在Job之上。CronJob实例类似于Unix crontab（cron表）的一行，管理Job的时间方面。它允许在指定的时间点周期性地执行一个Job。见例1-1的示例定义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-1. CronJob
apiVersion: batch/v1beta1
kind: CronJob
metadata: 
  name: random-generator
spec: 
  # Every three minutes
  schedule:&amp;quot;*/3****&amp;quot;
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - image: k8spatterns/random-generator:1.0
            name: random-generator command: [ &amp;quot;java&amp;quot;, &amp;quot;-cp&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;RandomRunner&amp;quot;, &amp;quot;/numbers.txt&amp;quot;, &amp;quot;10000&amp;quot; ]
          restartPolicy: OnFailure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了Job规格外，CronJob还有额外的字段来定义它的时间方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.spec.schedule&lt;br&gt;
Crontab 条目用于指定Job的计划（例如，0 * * * * 表示每小时运行）。&lt;/li&gt;
&lt;li&gt;.spec.startingDeadlineSeconds&lt;br&gt;
如果任务错过了预定时间，启动任务的最后期限（以秒为单位）。在某些使用情况下，一个任务只有在一定的时间范围内执行才有效，如果执行晚了就没有用了。例如，如果一个Job因为缺乏计算资源或其他缺失的依赖关系而没有在预期的时间内执行，那么最好跳过一次执行，因为它应该处理的数据已经过时了。&lt;/li&gt;
&lt;li&gt;.spec.concurrencyPolicy&lt;br&gt;
指定如何管理同一 CronJob 创建的作业的并发执行。默认行为Allow会创建新的Job实例，即使之前的Job还没有完成。如果这不是所需的行为，可以在当前作业尚未完成的情况下，使用 Forbidor 跳过下一次运行，取消当前正在运行的作业，并使用 Replace 启动一个新的作业。&lt;/li&gt;
&lt;li&gt;.spec.suspend&lt;br&gt;
暂停所有后续执行，但不影响已经开始的执行。&lt;/li&gt;
&lt;li&gt;.spec.successfulJobsHistoryLimit and .spec.failedJobsHistoryLimit&lt;br&gt;
指定应保留多少个已完成和未完成的Job的字段，以便进行审计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CronJob是一个非常专业的基元，它只适用于工作单元具有时间维度的情况。即使CronJob不是一个通用的基元，它也是一个很好的例子，说明Kubernetes的能力是如何建立在彼此之上，并且也支持非云原生用例。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;正如您所看到的，CronJob是一个非常简单的基元，它向现有的Job定义添加了集群、类似Cron的行为。但当它与其他基元（如 Pods、容器资源隔离）和其他 Kubernetes 特性（如 ，Automated Placement、Health Probe）相结合时，它往往会成为一个非常强大的 Job 调度系统。这使得开发者可以只关注问题域，实现一个只负责要执行的业务逻辑的容器化应用。调度是在应用之外进行的，作为平台的一部分，它具有所有的附加优势，如高可用性、弹性、容量和策略驱动的Pod调度。当然，与Job的实现类似，在实现CronJob容器时，你的应用必须考虑重复运行、不运行、并行运行或取消运行的所有角落和故障情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K8s中批量Job设计模式</title>
      <link>https://kubesphereio.com/post/batch-job/</link>
      <pubDate>Sun, 03 Jan 2021 16:00:45 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/batch-job/</guid>
      <description>&lt;p&gt;Batch Job模式适合管理孤立的原子工作单元。它基于Job抽象，在分布式环境中可靠地运行短暂的Pod，直到完成。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;Kubernetes中管理和运行容器的主要基元是Pod。创建Pod的方式有不同的特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bare Pod&lt;br&gt;
可以手动创建一个Pod来运行容器。然而，当这种Pod运行的节点出现故障时，Pod不会被重新启动。不鼓励以这种方式运行Pod，除非出于开发或测试目的。这种机制也被称为非托管或裸露的Pod。&lt;/li&gt;
&lt;li&gt;ReplicaSet&lt;br&gt;
该控制器用于创建和管理预期连续运行的Pod的生命周期（例如，运行一个Web服务器容器）。在任何给定时间中，它维护一组稳定的副本Pods运行，并保证指定数量相同的Pods可用。&lt;/li&gt;
&lt;li&gt;DaemonSet&lt;br&gt;
控制器以单个Pod方式运行在每个节点上。通常用于管理平台功能，如监控、日志收集、存储容器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些Pod的一个共同点是，它们代表了长期运行的进程，并不是要在一段时间后停止。然而，在某些情况下，需要可靠地执行一个预定义的限定的工作，然后关闭容器。对于这个任务，Kubernetes提供了Job资源。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;Kubernetes Job类似于ReplicaSet，因为它创建了一个或多个Pod，并确保它们成功运行。然而，不同的是，一旦预期数量的Pod成功终止，该作业就被认为是完成的，不再启动额外的Pod。一个Job定义看起来像例 1-1。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.1 Job实例
apiVersion: batch/v1
kind: Job
metadata:
  name: random-generator
spec:
  completions: 5
  parallelism: 2
  template:
    metadata:
      name: random-generator
    spec:
      restartPolicy: OnFailure
      containers:
      - image: k8spatterns/random-generator:1.0
        name: random-generator
        command: [ &amp;quot;java&amp;quot;, &amp;quot;-cp&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;RandomRunner&amp;quot;, &amp;quot;/numbers.txt&amp;quot;, &amp;quot;10000&amp;quot; ]
        
        
Job应该运行五个Pods来完成，这五个Pods必须全部成功。
有两个pod是并行的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Job 和 ReplicaSet 定义之间的一个重要区别是 .spec.template.spec.restartPolicy。ReplicaSet的默认值是Always，这对于必须始终保持运行的长期进程来说是有意义的。对于一个Job来说，不允许使用 Always 值，唯一可能的选项是 OnFailure 或Never。&lt;/p&gt;
&lt;p&gt;那么，为什么还要创建一个Job及只运行一次Pod，而不是使用裸Pod呢？使用Job提供了许多可靠性和可扩展性的优势，使其成为首选。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个Job不是一个短暂的内存中的任务，而是一个持久的任务，可以在集群重启后存活下来。&lt;/li&gt;
&lt;li&gt;当一个作业完成时，它不会被删除，但会被保留以用于跟踪。作为Job的一部分创建的Pods也不会被删除，但可用于检查（例如，检查容器日志）。对于裸露的Pods也是如此，但只适用于restartPolicy: OnFailure。&lt;/li&gt;
&lt;li&gt;一个Job可能需要执行多次。使用.spec.completions字段可以指定一个Pod在Job本身完成之前应该成功完成多少次。&lt;/li&gt;
&lt;li&gt;当一个Job必须多次完成时（通过.spec.completions设置），它也可以通过同时启动多个Pod来扩展和执行。这可以通过指定.spec.parallelism字段来实现。&lt;/li&gt;
&lt;li&gt;如果节点出现故障，或者当Pod因某种原因被驱逐，而仍在运行时，调度器会将Pod调度在一个新的健康节点上并重新运行。裸露的Pod将保持在失败的状态，因为现有的Pod永远不会被移动到其他节点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有这些都使得Job基元对于那些需要对单位工作的完成进行一些保证的场景具有吸引力。在Job的行为中起主要作用的两个字段是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.spec.completions&lt;br&gt;
指定应运行多少个Pods来完成一个Job。&lt;/li&gt;
&lt;li&gt;.spec.parallelism&lt;br&gt;
指定多少个Pod副本可以并行运行。设置较高的数字并不能保证较高的并行性，实际的Pod数量可能仍然少于（在某些特殊的情况下，更多）所需的数量（例如，由于节流、资源配额、剩余的完成量不够以及其他原因）。将此字段设置为 0，可以有效地暂停作业。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;图1-1显示了例1-1中定义的完成数为5，并行度为2的Batch Job的处理方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1gm51lqx1f7j30du0590t5.jpg&#34; alt=&#34;批量job.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据这两个参数，有以下几种类型的Job：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single Pod Job&lt;br&gt;
当您不考虑.spec.completions和.spec.parallelism或将它们设置为默认值1时，就会选择这种类型。这样的Job只启动一个Pod，一旦单个Pod成功终止（退出代码为0），就会完成。&lt;/li&gt;
&lt;li&gt;Fixed completion count Jobs&lt;br&gt;
当你指定.spec.completions的数字大于1时，这个数量的Pod必须成功。您可以选择设置.spec.parallelism，或者将其保留为默认值1。这样的Job在.spec.completions数量的Pods成功完成后，就被认为是完成了。例1-1展示了这种模式的运行情况，当我们事先知道Jobs的数量，并且单个工作项的处理成本证明了使用专用Pod的合理性时，这是最好的选择。&lt;/li&gt;
&lt;li&gt;Work queue Jobs&lt;br&gt;
当您不使用 .spec.completions 并将 .spec.parallelism 设置为大于 1 的整数时，您就拥有了一个并行Job的工作队列。当至少有一个Pod成功终止，并且所有其他Pod也终止时，一个工作队列Job就被认为已经完成。这种设置需要Pods之间相互协调，确定每个Pods正在进行的工作，这样才能以协调的方式完成。例如，当队列中存储了固定但未知数量的工作项目时，并行的Pods可以逐个拾取这些项目进行工作。第一个检测到队列为空并成功退出的Pod表示Job完成。Job控制器也会等待所有其他Pod终止。由于一个Pod处理多个工作项目，这种Job类型是细化工作项目的最佳选择&amp;ndash;当每个工作项目的一个Pod的开销是不合理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你有无限的工作项流需要处理，其他控制器（如ReplicaSet）是管理处理这些工作项目的Pod的更好选择。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;Job抽象是一个非常基本但也是基本的基元，其他基元（如 CronJobs）都是基于这个基元。Job有助于将孤立的工作单元转化为可靠和可扩展的执行单元。然而，Job 并不决定如何将可单独处理的工作项映射到 Jobs 或 Pods 中。这是你必须在考虑每个选项的利弊后确定的事情。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One Job per work item&lt;br&gt;
这个选项有创建Kubernetes Jobs的开销，也为平台管理大量消耗资源的Job。当每个工作项目都是一个复杂的任务时，必须记录、跟踪或缩放时，这个选项很有用。&lt;/li&gt;
&lt;li&gt;One Job for all work items&lt;br&gt;
这个选项适用于大量的工作项目，这些项目不需要由平台独立跟踪和管理。在这种情况下，工作项目必须通过批处理框架从应用程序内部进行管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Job 基元只为工作项目的调度提供了最基本的基础知识。任何复杂的实现都必须将Job基元与批处理应用框架（例如，在Java生态系统中，我们将Spring Batch和JBeret作为标准实现）结合起来，以达到预期的结果。&lt;/p&gt;
&lt;p&gt;不是所有的服务都必须一直运行。有些服务必须按需运行，有些必须在特定的时间运行，有些必须定期运行。使用Jobs可以只在需要的时候运行Pod，并且只在任务执行期间运行。Jobs被安排在具有所需容量的节点上，满足Pod调度策略和其他容器依赖性考虑。使用Jobs来执行短时任务，而不是使用长期运行的抽象（如ReplicaSet），可以为平台上的其他工作负载节省资源。所有这些都使得Jobs成为一个独特的基元，而Kubernetes则是一个支持多样化工作负载的平台。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K8s中自动调度设计模式</title>
      <link>https://kubesphereio.com/post/automated-placement/</link>
      <pubDate>Sat, 02 Jan 2021 18:15:51 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/automated-placement/</guid>
      <description>&lt;p&gt;Automated Placement是Kubernetes调度器的核心功能，用于将新的Pod分配给满足容器资源请求的节点，并遵从调度策略。该模式描述了Kubernetes的调度算法的原理以及从外部影响调度决策的方式。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;一个合理规模的基于微服务的系统由几十个甚至几百个独立的进程组成。容器和Pods确实为打包和部署提供了很好的抽象实例，但并不能解决将这些进程调度在合适节点上的问题。随着微服务数量的庞大和不断增长，将它们单独分配和调度到节点上并不是一个可以管理的活动。&lt;/p&gt;
&lt;p&gt;容器之间有依赖性，对节点的依赖性，还有资源需求，所有这些也会随着时间的推移而变化。集群上的可用资源也会随着时间的推移而变化，通过收缩或扩展集群，或者被已经调度的容器消耗掉。我们调度容器的方式也会影响分布式系统的可用性、性能和容量。所有这些都使得将容器调度到节点上成为一个变化的目标，必须在变化中确定下来。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;在Kubernetes中，将Pod分配给节点是由调度器完成的。截至本文写作时，这是一个可配置性很强、仍在不断发展、变化很快的领域。在本章中，我们将介绍主要的调度控制机制、影响调度的驱动力、为什么要选择一种或另一种方案，以及由此产生的后果。Kubernetes调度器是一个有效且省时的工具。它在整个Kubernetes平台中起着基础性的作用，但与其他Kubernetes组件（API Server、Kubelet）类似，它可以单独运行，也可以完全不使用。&lt;/p&gt;
&lt;p&gt;在一个很高的层次上，Kubernetes调度器执行的主要操作是从API Server上监控每个新创建的Pod定义，并将其分配给一个节点。它为每一个Pod找到一个合适的节点（只要有这样的节点），无论是最初的应用调度、扩容，还是将应用从一个不健康的节点转移到一个更健康的节点时。它还考虑运行时的依赖性、资源需求和高可用性的指导策略，通过横向扩展Pod，也通过将附近的Pod进行性能和低延迟交互的方式来实现。然而，为了让调度器正确地完成它的工作，并允许声明式的调度，它需要有可用容量的节点，以及有声明式资源配置文件和指导策略的容器。让我们更详细地看看其中的每一个。&lt;/p&gt;
&lt;h4 id=&#34;available-node-resources&#34;&gt;Available Node Resources&lt;/h4&gt;
&lt;p&gt;首先，Kubernetes集群需要有足够资源容量的节点来运行新的Pod。每个节点都有可用于运行Pod的容量，调度器确保一个Pod所请求的资源之和小于可分配的节点容量。考虑到一个只专用于Kubernetes的节点，其容量使用例1-1中的公式计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例1-1. node容量
Allocatable[capacity for application pods] = Node Capacity[available capacity on a ndoe] - kube-Reserved[Kubernetes daemons like kubelet, container runtime] - System-Reserved[os system daemons like sshd udev]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你没有为给操作系统和Kubernetes本身提供动力的系统守护进程预留资源，那么Pods的调度可能会达到节点的全部容量，这可能会导致Pods和系统守护进程争夺资源，导致节点上的资源不足问题。同时要记住，如果容器运行在非Kubernetes管理的节点上，反映在Kubernetes的节点容量计算中。&lt;/p&gt;
&lt;p&gt;这个限制的一个变通方法是运行一个空的Pod，它不做任何事情，只是对CPU和内存的资源请求与未跟踪容器的资源使用量相对应。创建这样的Pod只是为了表示和保留未跟踪容器的资源消耗量，帮助调度器建立更好的节点资源模型。&lt;/p&gt;
&lt;h4 id=&#34;container-resource-demands&#34;&gt;Container Resource Demands&lt;/h4&gt;
&lt;p&gt;高效的Pod调度的另一个重要要求是，容器有其运行时的依赖性和资源需求的定义。归根结底就是要让容器声明它们的资源概况（有请求和限制）和环境依赖性，如存储或端口。只有这样，Pod才会被合理地分配到节点上，并能在高峰期不影响彼此的运行。&lt;/p&gt;
&lt;h4 id=&#34;调度策略&#34;&gt;调度策略&lt;/h4&gt;
&lt;p&gt;最后一块拼图是拥有正确的过滤或优先级策略来满足你的特定应用需求。调度器配置了一套默认的判断和优先级策略，这对大多数应用来说已经足够了。在调度程序启动时，可以用不同的策略来覆盖它，如例1-2所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-2. 调度策略
{ 
    &amp;quot;kind&amp;quot;:&amp;quot;Policy&amp;quot;,
    &amp;quot;apiVersion&amp;quot;:&amp;quot;v1&amp;quot;,
    &amp;quot;predicates&amp;quot;:[ 
        {&amp;quot;name&amp;quot;:&amp;quot;PodFitsHostPorts&amp;quot;},
        {&amp;quot;name&amp;quot;:&amp;quot;PodFitsResources&amp;quot;},
        {&amp;quot;name&amp;quot;:&amp;quot;NoDiskConflict&amp;quot;},
        {&amp;quot;name&amp;quot;:&amp;quot;NoVolumeZoneConflict&amp;quot;},
        {&amp;quot;name&amp;quot;:&amp;quot;MatchNodeSelector&amp;quot;},
        {&amp;quot;name&amp;quot;:&amp;quot;HostName&amp;quot;}
    ],
    &amp;quot;priorities&amp;quot;:[ 
        {&amp;quot;name&amp;quot;:&amp;quot;LeastRequestedPriority&amp;quot;,&amp;quot;weight&amp;quot;:2},
        {&amp;quot;name&amp;quot;:&amp;quot;BalancedResourceAllocation&amp;quot;,&amp;quot;weight&amp;quot;:1},
        {&amp;quot;name&amp;quot;:&amp;quot;ServiceSpreadingPriority&amp;quot;,&amp;quot;weight&amp;quot;:2},
        {&amp;quot;name&amp;quot;:&amp;quot;EqualPriority&amp;quot;,&amp;quot;weight&amp;quot;:1}
    ]
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;判断是过滤掉不合格节点的规则。例如，PodFitsHostsPortsschedules Pods只在那些还有这个端口的节点上请求某些固定的主机端口。&lt;/li&gt;
&lt;li&gt;优先级是根据偏好对可用节点进行排序的规则。例如，LeastRequestedPriority 给予请求资源较少的节点较高的优先级。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到除了配置默认调度器的策略外，还可以运行多个调度器，并允许Pod指定调度哪个调度器。你可以给它一个唯一的名字来启动另一个配置不同的调度器实例。然后在定义Pod时，只需在Pod规范中添加字段.spec.scheduleName，并将你的自定义调度器名称添加到Pod规范中，Pod就会只被自定义调度器接收。&lt;/p&gt;
&lt;h4 id=&#34;调度过程&#34;&gt;调度过程&lt;/h4&gt;
&lt;p&gt;Pods根据调度策略被分配到具有一定容量的节点上。为了完整起见，图1-1在高层次上直观地展示了这些元素是如何结合在一起的，以及Pod在被调度时经历的主要步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1gm2qomk2ljj30cf08xq4c.jpg&#34; alt=&#34;调度过程.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;一旦创建了一个尚未分配给节点的Pod，它就会被调度器挑选出来，连同所有可用的节点以及过滤和优先级策略集。在第一阶段，调度器应用过滤策略，并根据Pod的标准删除所有不合格的节点。在第二阶段，剩余的节点得到按权重排序。在最后一个阶段，Pod得到一个节点分配，这是调度过程的主要结果。&lt;/p&gt;
&lt;p&gt;在大多数情况下，最好是让调度程序来完成Pod到节点的分配，而不是微观管理调度逻辑。然而，在某些情况下，你可能想强制将一个Pod分配到一个特定的节点或一组节点。这种分配可以使用节点选择器来完成。.spec.nodeSelector是Pod字段，指定了一个键值对的映射，这些键值对必须作为标签存在于节点上，该节点才有资格运行Pod。例如，假设你想强制Pod运行在有SSD存储或GPU加速硬件的特定节点上。在例1-3中的Pod定义中，nodeSelector匹配disktype：ssd，只有标签为disktype=ssd的节点才有资格运行Pod。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-3. Node基于可用disk类型选择
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
  nodeSelector:
    disktype: ssd
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除了给节点指定自定义标签外，你还可以使用一些每个节点上都有的默认标签。每个节点都有一个唯一的kubernetes.io/hostname标签，可以通过其主机名将Pod调度在节点上。其他表示操作系统、架构和实例类型的默认标签对调度也很有用。&lt;/p&gt;
&lt;h4 id=&#34;node-affinity&#34;&gt;Node Affinity&lt;/h4&gt;
&lt;p&gt;Kubernetes支持许多更灵活的方式来配置调度过程。节点亲和力就是这样一个特性，它是前面介绍的节点选择器方法的泛化，允许将规则指定为必填或优先。必需的规则必须满足，Pod才会被调度到某个节点，而优先的规则只是通过增加匹配节点的权重来暗示偏好，而不是强制性的。此外，节点亲和性功能极大地扩展了你可以表达的约束类型，通过In、NotIn、Exists、DoesNotExist、Gt或Lt等运算符使语言更具表现力，例1-4演示了如何声明节点亲和性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.4 节点亲和性
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: numberCores
            operator: Gt
            values: [ &amp;quot;3&amp;quot; ]
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 1
        preference:
          matchFields:
          - key: metadata.name
            operator: NotIn
            values: [ &amp;quot;master&amp;quot; ]
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;pod-affinity-and-antiaffinity&#34;&gt;Pod Affinity and Antiaffinity&lt;/h4&gt;
&lt;p&gt;节点亲和力是一种更强大的调度方式，当nodeSelector不够用时，应该优先考虑。这种机制允许根据标签或字段匹配来限制一个Pod可以运行的节点，但它不允许表达Pod之间的依赖关系来决定一个Pod的相对位置。它不允许表达Pod之间的依赖关系，来决定一个Pod相对于其他Pod应该调度在哪里。为了表达Pod应该如何分布以实现高可用性，或被打包并集中在一起以改善延迟，可以使用Pod亲和力和反亲和力。&lt;/p&gt;
&lt;p&gt;节点亲和力在节点粒度上工作，但Pods亲和力不限于节点，可以在多个拓扑层次上表达规则。使用==topologyKey字段和匹配的标==签，可以执行更细粒度的规则，这些规则结合了节点、机架、云提供商区域和区域等域的规则，如例1-5所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-5. Pod亲和性
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            confidential: high
        topologyKey: security-zone
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
        labelSelector:
          matchLabels:
            confidential: none
        topologyKey: kubernetes.io/hostname
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与节点亲和力类似，Pod亲和力和反亲和力也有硬性要求和软性要求，分别称为requiredDuringSchedulingIgnoredDuringExecution和preferredDuringSchedulingIgnoredDuringExecution。同样，和节点亲和力一样，字段名中也有IgnoredDuringExecution的后缀，这是为了将来的可扩展性而存在的。目前，如果节点变化和亲和力规则上的标签不再有效，Pods就会继续运行，但未来运行时的变化也可能被考虑在内。&lt;/p&gt;
&lt;h4 id=&#34;taints-and-tolerations&#34;&gt;Taints and Tolerations&lt;/h4&gt;
&lt;p&gt;一个更高级的功能是基于污点和容忍来控制Pods可以被调度和允许运行的地方。节点亲和力是Pods的一个属性，它允许Pods选择节点，而污点和容忍则相反。它们允许节点控制哪些Pods应该或不应该被调度在它们上面。污点是节点的一个特性，当它存在时，它阻止Pods调度到节点上，除非Pod对污点有容忍度。从这个意义上说，污点和容忍可以被认为是允许调度到节点上的一种选择，默认情况下，这些节点是不能被调度的，而亲和规则则是一种选择，通过明确选择在哪些节点上运行，从而排除所有非选择的节点。&lt;/p&gt;
&lt;p&gt;通过使用kubectl给一个节点添加污点：kubectl taint nodes master node-role.kubernetes.io/master=&amp;quot;true&amp;rdquo;:NoSchedule，其效果如例1-6所示。如例1-7所示，将匹配的toleration添加到Pod中。注意，例1-6中taints部分的key和effect的值和例1-7中tolerations:部分的值是一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.6 node污点
apiVersion: v1
kind: node
metadata:
  name: master
spec:
  taints:
  - effect: NoSchedule
  key: node-role.kubernetes.io/master
  
1.7 Pod忍受和node污点
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
  tolerations:
  - key: node-role.kubernetes.io/master
    operator: Exists
    effect: NoSchedule
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有防止在节点上调度的硬污点(effect=NoSchedule)，有尽量避免在节点上调度的软污点(effect=PreferNoSchedule)，还有可以从节点上驱逐已经运行的Pod的污点(effect=NoExecute)。&lt;/p&gt;
&lt;p&gt;污点和容忍允许复杂的用例，比如为一组专属的Pods设置专用节点，或者通过这些污点节点强制将Pods从有问题的节点驱逐出去。&lt;/p&gt;
&lt;p&gt;你可以根据应用的高可用性和性能需求来影响调度，但尽量不要对调度器限制太多，把自己退到一个角落里，不能再调度Pods，搁浅的资源太多。比如，如果你的容器资源需求粒度太粗，或者节点太小，最后可能会出现节点中的搁浅资源没有被利用的情况。&lt;/p&gt;
&lt;p&gt;在图1-2中，我们可以看到节点A有4GB的内存无法利用，因为没有CPU可以放置其他容器。创建具有较小resourcere quirements的容器可能有助于改善这种情况。另一个解决方案是使用Kubernetes descheduler，它有助于分解节点，提高节点的利用率。&lt;/p&gt;
&lt;p&gt;一旦Pod被分配到一个节点上，调度器的工作就完成了，它不会改变Pod调度的位置，除非在没有节点分配的情况下删除和重新创建Pod。正如你所看到的，随着时间的推移，这可能会导致资源碎片化和集群资源利用率低下。另一个潜在的问题是，当一个新的Pod被调度时，调度器的决策是基于其集群视图的。如果一个集群是动态的，节点的资源情况发生了变化，或者增加了新的节点，调度器就不会纠正之前的Pod调度情况。除了改变节点容量外，还可以改变节点上的标签，影响调度，但过去的调度也不会被修正。&lt;/p&gt;
&lt;p&gt;所有这些都是descheduler可以解决的场景。Kubernetes descheduler是一个可选的功能，通常在集群管理员决定是时候通过重新安排Pods来整理和分解集群时，它就会以Job的形式运行。descheduler带有一些预定义的策略，可以启用、调整或禁用。这些策略以文件的形式传递给descheduler Pod，目前，它们有以下几种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RemoveDuplicates&lt;br&gt;
该策略可确保只有与 ReplicaSet 或Deployment 相关联的单个 Pod 在单个节点上运行。如果Pod数量超过一个，这些多余的Pod将被驱逐。该策略在节点变得不健康的情况下非常有用，管理控制器在其他健康节点上启动了新的Pod。当不健康的节点恢复并加入集群时，运行中的Pod数量超过了预期，descheduler可以帮助将数量恢复到预期的副本数。当调度策略和集群拓扑结构在初始调度后发生变化时，去除节点上的重复也可以帮助Pods在更多节点上均匀分布。&lt;/li&gt;
&lt;li&gt;LowNodeUtilization&lt;br&gt;
该策略可以找到未被充分利用的节点，并从其他过度利用的节点上驱逐Pod，希望将这些Pod调度在未被充分利用的节点上，从而更好地分散和利用资源。未充分利用的节点被识别为CPU、内存或Pod数量低于配置阈值的节点。同样，过度利用的节点是指那些值大于配置的目标阈值的节点。介于这些值之间的任何节点都被适当利用，不受该策略的影响。&lt;/li&gt;
&lt;li&gt;RemovePodsViolatingInterPodAntiAffinity&lt;br&gt;
这个策略驱逐的Pods违反了Pods间的反亲和规则，这可能发生在Pods被调度在节点上后添加反亲和规则时。&lt;/li&gt;
&lt;li&gt;RemovePodsViolatingNodeAffinity&lt;br&gt;
这个策略是用来驱逐违反节点亲和规则的Pods的。&lt;/li&gt;
&lt;li&gt;Regardless of the policy used, the descheduler avoids evicting the followding：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;标有scheduler.alpha.kubernetes.io/critical-pod注释的临界Pods。
非ReplicaSet，Deployment和Job管理的pod。
DaemonSet管理的pod。
Pods使用本地存储。
有PodDisruptionBudget的pods，驱逐将违反其规则。
Deschedule Pod本身（通过将自身标记为关键Pod实现）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，所有的驱逐都会尊从Pods的QoS水平，先选择Best-EffortsPods,然后是Burstable Pods，最后是Guaranteed Pods作为驱逐的候选者。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;调度是一个你希望尽可能少干预的领域。可预测的需求，并声明容器的所有有源需求，调度器会做它的工作，并将Pod放置在最合适的节点上。然而，当这还不够的时候，有多种方法可以引导调度器朝向所需的部署拓扑。综上所述，从简单到复杂，以下方法控制了Pod调度（请记住，截至本文撰写时，这个列表会随着Kubernetes的每一个其他版本而改变）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nodeName&lt;br&gt;
最简单硬形式为Pod到节点。这个字段最好由调度器填充，它由策略驱动，而不是手动分配节点。将Pod分配到节点上，极大地限制了Pod的调度范围。这让我们回到了前Kubernetes时代，当时我们明确指定了运行应用的节点。&lt;/li&gt;
&lt;li&gt;nodeSelector&lt;br&gt;
指定键值对的映射。为了使Pod有资格在节点上运行，Pod必须有指定的键值对作为节点上的标签。在Pod和节点上贴上一些有意义的标签后（无论如何你都应该这么做），节点选择器是控制调度器选择的最简单可接受的机制之一。&lt;/li&gt;
&lt;li&gt;Default scheduling alteration&lt;br&gt;
默认的调度器负责将新的Pod调度到集群内的节点上，而且它做得很合理。但是，如果有必要，可以改变这个调度器的过滤和优先策略列表、顺序和权重。&lt;/li&gt;
&lt;li&gt;Pod affinity and antiaffinity&lt;br&gt;
这些规则允许一个Pod表现对其他Pod的依赖性，例如，一个应用的延迟要求、高可用性、安全约束等。&lt;/li&gt;
&lt;li&gt;Node affinity&lt;br&gt;
这个规则允许Pod向节点表现依赖性。例如，考虑节点的硬件、位置等。&lt;/li&gt;
&lt;li&gt;Taints and tolerations&lt;br&gt;
Taints和tolerations允许节点控制哪些Pods应该或不应该被调度在它们上面。例如，为一组Pod致力一个节点，甚至在运行时驱逐Pod。Taints和Tolerations的另一个优点是，如果你通过添加带有新标签的新节点来扩展Kubernetes集群，你不需要在所有Pod上添加新标签，而只需要在应该放在新节点上的Pod上添加。&lt;/li&gt;
&lt;li&gt;Custom scheduler&lt;br&gt;
如果前面的方法都不够好，或者你有复杂的调度需求，你也可以写你的自定义调度器。自定义的调度器可以代替标准的Kubernetes调度器运行，也可以和标准的Kubernetes调度器一起运行。Ahybrid的做法是有一个 &amp;ldquo;调度扩展器 &amp;ldquo;进程，标准Kubernetes调度器在做调度决策时，会调用这个进程作为最后的通道。这样你就不用实现一个完整的调度器，而只需要提供HTTP API来过滤和优先处理节点。拥有自己的调度器的好处是，你可以考虑Kubernetes集群之外的因素，比如硬件成本、网络延迟和更好的利用率，同时将Pod分配给节点。你也可以在使用默认调度器的同时使用多个自定义调度器，并为每个Pod配置使用哪个调度器。每个调度器可以有一套不同的策略，专门用于Pod的子集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如你所看到的，有很多方法可以控制Pod的放置，选择正确的方法或结合多种方法是很有挑战性的。本章的启示是：确定容器资源配置文件的大小和声明，给Pod和节点打上相应的标签，最后，只对Kubernetes调度器做最小的干预。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K8s中生命周期管理设计模式</title>
      <link>https://kubesphereio.com/post/managed-lifecycle/</link>
      <pubDate>Wed, 30 Dec 2020 20:32:48 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/managed-lifecycle/</guid>
      <description>&lt;p&gt;由云原生平台管理的容器化应用对其生命周期没有控制权，要想成为优秀的云原生化 ，它们必须监听管理平台发出的事件，并相应地调整其生命周期。托管生命周期模式描述了应用程序如何能够并且应该对这些生命周期事件做出反应。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;健康探针我们解释了为什么容器要为不同的健康检查提供API。健康检查API是平台不断探查以获取应用洞察力的只读endpoints。它是平台从应用中提取信息的一种机制。&lt;/p&gt;
&lt;p&gt;除了监控容器的状态外，平台有时可能会发出命令，并期望应用程序对此做出反应。在策略和外部因素的驱动下，云原生平台可能会在任何时刻决定启动或停止其管理的应用程序。容器化应用要决定哪些事件是重要的，要做出反应以及如何反应。但实际上，这是一个API，平台是用来和应用进行通信和发送命令的。另外，如果应用程序不需要这项服务，他们可以自由地从生命周期管理中获益，或者忽略它。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;我们看到，只检查进程状态并不能很好地显示应用程序的健康状况。这就是为什么有不同的API来监控容器的健康状况。同样，只使用进程模型来运行和停止一个进程是不够好的。现实世界中的应用需要更多的细粒度交互和生命周期管理能力。有些应用需要帮助预热，有些应用需要优雅而不带缓存的关闭程序。对于这种和其他用例，一些事件，如图1-1所示，由平台发出，容器可以监听并在需要时做出反应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1gm1kg6aoq6j309i03bmx8.jpg&#34; alt=&#34;生命周期.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;应用程序的部署单元是一个Pod。你已经知道，一个Pod由一个或多个容器组成。在Pod层面，还有其他的构造，比如init容器、init Container（以及defer-containers，截止到目前还在提案阶段），可以帮助管理容器的生命周期。我们在本章中描述的事件和钩子都是应用在单个容器级别而不是Pod级别。&lt;/p&gt;
&lt;h4 id=&#34;sigterm-signal&#34;&gt;SIGTERM Signal&lt;/h4&gt;
&lt;p&gt;每当Kubernetes决定关闭一个容器时，无论是因为它所属的Pod正在关闭，还是仅仅是一个失败的liveness探测导致容器重新启动，容器都会收到一个SIGTERM信号。SIGTERM是在Kubernetes发出更突然的SIGKILL信号之前，温柔地戳一下容器，让它干净利落地关闭。一旦收到SIGTERM信号，应用程序应该尽快关闭。对于一些应用来说，这可能是一个快速的终止，而其他一些应用可能必须完成其飞行中的请求，释放开放的连接，并清理临时文件，这可能需要稍长的时间。在所有的情况下，对SIGTERM做出反应是以正确时刻和干净的方式关闭容器。&lt;/p&gt;
&lt;h4 id=&#34;sigkill-signal&#34;&gt;SIGKILL Signal&lt;/h4&gt;
&lt;p&gt;如果容器进程在发出SIGTERM信号后还没有关闭，则会被下面的SIGKILL信号强制关闭。Kubernetes不会立即发送SIGKILL信号，而是在发出SIGTERM信号后默认等待30秒的宽限期。这个宽限期可以使用.spec.terminalGracePeriodSeconds字段为每个Pod定义，但不能保证，因为它可以在向Kubernetes发出命令时被覆盖。这里的目的应该是设计和实现容器化应用，使其具有短暂性的快速启动和关闭进程。&lt;/p&gt;
&lt;h4 id=&#34;poststart-hook&#34;&gt;Poststart Hook&lt;/h4&gt;
&lt;p&gt;只使用过程信号来管理生命周期是有一定局限性的。这就是为什么Kubernetes提供了额外的生命周期钩子，如postStart和preStop。包含postStart钩子的Pod清单看起来像例5-1中的那个。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例1-1，容器中配置poststart hook
apiVersion: v1
kind: Pod
metadata:
  name: post-start-hook
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    lifecycle:
      postStart:
        exec:
          command:
          - sh
          - -c
          - sleep 30 &amp;amp;&amp;amp; echo &amp;quot;Wake up!&amp;quot; &amp;gt; /tmp/postStart_done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;postStart命令在这里等待30秒。sleep只是模拟任何可能在这里运行的冗长启动代码。另外，它在这里使用一个触发器文件与主应用程序同步，主应用程序是并行启动的。&lt;/p&gt;
&lt;p&gt;postStart 命令在容器创建后与主容器的进程异步执行。即使许多应用程序的初始化和预热逻辑可以作为容器启动步骤的一部分来实现，postStart仍然涵盖了一些用例。postStart动作是一个阻塞调用，容器状态保持为Waiting，直到postStart处理程序完成，这又使Pod状态保持为Pending状态。postStart的这种性质可以用来延迟容器的启动状态，同时给容器主进程初始化的时间。&lt;/p&gt;
&lt;p&gt;postStart的另一个用途是当Pod不满足某些前提条件时，防止容器启动。例如，当postStart钩子通过返回一个非零的退出代码来指示错误时，主容器进程会被Kubernetes杀死。&lt;/p&gt;
&lt;p&gt;postStart和preStophook调用机制类似于所述的健康探针，并支持这些处理程序类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exec  直接在容器中运行指令&lt;/li&gt;
&lt;li&gt;httpGet  对一个Pod容器监听的端口执行HTTP GET请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你必须非常小心地执行postStart钩子中的关键逻辑，因为它的执行没有保证。由于钩子是与容器进程并行运行的，所以钩子有可能在容器启动之前就被执行了。另外，钩子的目的是至少有一次语义，所以实现必须照顾到重复的执行。另一个需要注意的方面是，平台不会对没有到达处理程序的HTTP请求失败执行任何重试尝。&lt;/p&gt;
&lt;h4 id=&#34;prestop-hook&#34;&gt;Prestop Hook&lt;/h4&gt;
&lt;p&gt;preStop 钩子是在容器被终止之前向其发送的阻塞调用，它与 SIGTERM 信号具有相同的语义，在无法对 SIGTERM 作出反应时，应使用它来优雅关闭容器。它与SIGTERM信号具有相同的语义，当无法对SIGTERM作出反应时，它应该被用来启动容器的优雅关闭。例 1-2 中的 preStop 动作必须在删除容器的调用被发送到容器运行时之前完成，后者会触发 SIGTERM 通知。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-2. 容器中配置preStop Hook
apiVersion: v1
kind: Pod
metadata:
  name: pre-stop-hook
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    lifecycle:
      preStop:
        httpGet:
          port: 8080
          path: /shutdown
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即使preStop正在阻塞，按住它或返回一个不成功的结果并不能阻止容器被删除和进程被杀死。preStop只是一个方便的替代SIGTERM信号的优雅应用，仅此而已。它还提供了与我们之前介绍的postStart钩子相同的处理程序类型和保证。&lt;/p&gt;
&lt;h4 id=&#34;other-lifecycle-controls&#34;&gt;Other Lifecycle Controls&lt;/h4&gt;
&lt;p&gt;在本章中，到目前为止，我们已经关注了当容器生命周期事件发生时允许执行命令的钩子。但另一种机制不是在容器层面，而是在Pod层面，允许执行初始化指令。&lt;/p&gt;
&lt;p&gt;Init容器，深入浅出，但这里我们简单介绍一下，将其与生命周期钩子进行比较。与普通的应用容器不同，init容器按顺序运行，一直运行到完成，并且在Pod中任何一个应用容器启动之前运行。这些保证允许使用init容器进行Pod级初始化任务。生命周期钩子和init容器都以不同的粒度（分别在容器级和Pod级）运行，可以在某些情况下交替使用，或者在其他情况下相互补充。表1-1总结了两者的主要区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1gm1mmjpp7zj30gj05omy0.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了当你需要特定的时间保证时，使用哪种机制没有严格的规定。我们可以完全跳过生命周期钩子和初始化容器，使用bash脚本来执行特定的操作，作为容器启动或关闭命令的一部分。这是有可能的，但它会将容器与脚本紧密耦合，并将其变成维护的噩梦。&lt;/p&gt;
&lt;p&gt;我们还可以使用 Kubernetes 生命周期钩子来执行本章所述的一些动作。另外，我们还可以更进一步，运行使用init容器执行各个动作的容器。在这个序列中，这些选项越来越需要更多的提升，但同时也提供了更强的保障，并实现了重用。&lt;/p&gt;
&lt;p&gt;理解容器和Pod生命周期的阶段和可用钩子对于创建Kubernetes管理的应用来说是至关重要的。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;云原生平台提供的主要好处之一是能够在潜在的不可靠的云基础设施之上可靠和可预测地运行和扩展应用程序。这些平台为在其上运行的应用程序提供了一系列限制和共识。为了有利于应用程序，云原生平台提供的所有功能都遵守这些机制。处理和响应这些事件可以确保您的应用程序可以优雅地启动和关闭，对消费服务的影响最小。目前，在其基本形式下，这意味着容器应该像任何设计良好的POSIX进程一样行为。在未来，可能会有更多的事件给应用程序提示，当它即将被放大，或要求释放资源以防止被关闭。重要的是要进入这样的思维模式：应用程序的生命周期不再由人控制，而是由平台完全自动化。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K8s中健康检查设计模式</title>
      <link>https://kubesphereio.com/post/health-probe/</link>
      <pubDate>Tue, 29 Dec 2020 13:34:44 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/health-probe/</guid>
      <description>&lt;p&gt;健康探针模式是关于应用程序如何将其健康状态传达给Kubernetes。为了实现完全自动化，云原生应用必须具有高度的可观察性，允许推断其状态，以便Kubernetes能够检测应用是否已经启动，是否准备好服务的请求。这些观察结果会影响Pods的生命周期管理以及流量被路由到应用程序的方式。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;Kubernetes会定期检查容器进程状态，如果发现问题就会重新启动。然而，从实践中我们知道，检查进程状态并不足以决定应用程序的健康状况。在很多情况下，一个应用程序挂起了，但它的进程仍然在运行。例如，一个Java应用程序可能会抛出一个OutOfMemoryError，但JVM进程仍在运行。或者，一个应用程序可能会因为运行到一个无限循环、死锁或一些冲击（缓存、堆、进程）而冻结。为了检测这类情况，Kubernetes需要一种可靠的方法来检查应用程序的健康状况。也就是说，并不是要了解应用的内部工作情况，而是一种检查，表明应用是否按照预期运行，是否能够为消费者提供服务。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;软件业已经接受了这样一个事实，即不可能写出无错误的代码。此外，在使用分布式应用程序时，发生故障的机会就更多了。因此，处理故障的重点已经从避免故障转移到检测故障和恢复上。检测故障并不是一个简单的任务，不能对所有的应用统一执行，因为所有的应用对故障的定义都不同。而且，各种类型的故障需要不同的纠正措施。只要有足够的时间，暂时性的故障可能会自我恢复，而其他一些故障可能需要重新启动应用程序。让我们看看Kubernetes用来检测和纠正故障的检查。&lt;/p&gt;
&lt;h4 id=&#34;进程健康检查&#34;&gt;进程健康检查&lt;/h4&gt;
&lt;p&gt;进程健康检查是Kubelet不断对容器进程进行的最简单的健康检查。如果容器进程没有运行，就会重新启动探测。因此，即使没有任何其他的健康检查，应用程序也会因为这个通用检查而变得更加健壮。如果你的应用程序能够检测到任何类型的故障并关闭自己，那么进程健康检查就是你所需要的全部内容.然而，对于大多数情况下，这还不够，其他类型的健康检查也是必要的。&lt;/p&gt;
&lt;h4 id=&#34;liveness-probes&#34;&gt;Liveness Probes&lt;/h4&gt;
&lt;p&gt;如果你的应用程序运行到一些死锁，从进程健康检查的角度来看，它仍然被认为是健康的。为了根据你的==应用业务逻辑来检测==这种问题和任何其他类型的故障，Kubernetes有==liveness probes==&amp;ndash;由Kubelet代理定期执行检查，询问你的容器确认它仍然是健康的。重要的是要从外部而不是应用程序本身执行健康检查，因为一些故障可能会阻止应用程序看门狗报告其故障。关于纠正措施，这种健康检查类似于进程健康检查，因为如果检测到故障，容器就会重新启动。然而，在使用什么方法检查应用程序健康状况方面，它提供了更多的灵活性，如下所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP探针通过容器IP地址执行HTTP GET请求，并期望得到一个介于200和399之间的成功的HTTP响应代码。&lt;/li&gt;
&lt;li&gt;TCP Socket探针假设TCP连接成功。&lt;/li&gt;
&lt;li&gt;Exec探针在容器内核命名空间中执行一个任意命令，并期望有一个成功的退出代码（0）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;1.1 容器中配置liveness probe
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-liveness-check
spec:
  containers:
  - image: k8spatterns/random-generator:1.0 
    name: random-generator
    env:
    - name: DELAY_STARTUP
      value:&amp;quot;20&amp;quot; 
    ports:
    - containerPort: 8080
    protocol: TCP
    livenessProbe:
      httpGet:
      path: /actuator/health
      port: 8080
    initialDelaySeconds: 30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据您的应用程序的性质，您可以选择最适合您的方法。由您的实现来决定您的应用程序何时被认为是健康的或不健康的。然而，请记住，没有通过健康检查的结果是重启你的容器。如果重启你的容器没有帮助，那么健康检查失败没有任何好处，因为Kubernetes会重启你的容器而不解决根本问题。&lt;/p&gt;
&lt;h4 id=&#34;readiness-probes&#34;&gt;Readiness Probes&lt;/h4&gt;
&lt;p&gt;Liveness检查对于保持应用程序的健康非常有用，它可以杀死不健康的容器，并用新的容器替换它们。但有时一个容器可能并不健康，重启它可能也无济于事。最常见的例子是当一个容器还在启动，还没有准备好处理任何请求。或者是一个容器超载了，它的延迟在增加，你希望它暂时屏蔽掉额外的负载。&lt;/p&gt;
&lt;p&gt;对于这种场景，Kubernetes有Readiness探针。执行就绪性Readiness检查的方法与有效性检查（HTTP、TCP、Exec）相同，但纠正措施不同。失败的Readiness探针不是重启容器，而是导致容器从服务端点中移除，并且不接收任何新的流量。当容器准备就绪时，Readiness针会发出信号，以便它在受到服务请求的冲击之前有一段时间进行热身。它对于在后期阶段屏蔽服务的流量也很有用，因为Readiness探测会定期执行，类似于Liveness检查。例1-2展示了如何通过探测已运行的应用的内部文件是否存在来实现Readiness探测。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1-2 容器中配置readiness probe
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-readiness-check
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    readinessProbe:
      exec:  command: [ &amp;quot;stat&amp;quot;, &amp;quot;/var/run/random-generator-ready&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，由你对健康检查的实现来决定你的应用程序什么时候准备好做它的工作，什么时候应该让它自己去做。进程健康检查和liveness检查的目的是通过重启容器从故障中恢复，而readiness检查则是为你的应用程序争取时间，并期望它自己恢复。请记住，Kubernetes试图阻止你的容器接收新的请求（例如，当它正在关闭时），无论readiness检查是否在收到SIGTERM信号后仍然通过。&lt;/p&gt;
&lt;p&gt;在许多情况下，您可以同时执行liveness和readiness探针检查。然而，readiness探针的存在为您的容器提供了启动时间。只有通过了readiness检查，部署才被视为成功，因此，例如，使用旧版本的Pods可以作为滚动更新的一部分被终止。&lt;/p&gt;
&lt;p&gt;liveness和readiness探针是云原生应用程序自动化的基本构件。应用框架，如Spring执行器、WildFly Swarm健康检查、Karaf健康检查或Java的MicroProfile规范都提供了健康探针的实现。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;为了实现完全自动化，云原生应用必须具有高度可观察性，为管理平台提供读取和解释应用健康状况的方法，并在必要时采取纠正措施。健康检查在部署、自愈、扩展等活动的自动化中起着基础作用。然而，对于应用健康，您的应用程序还可以通过其他手段提供更多可见性。&lt;/p&gt;
&lt;p&gt;显而易见的、老的方法是通过日志记录来实现这一目的。对于容器来说，一个好的做法是记录任何重大的系统出错和系统错误事件，并将这些日志收集到一个中心位置以便进一步分析。日志通常不是用来采取自动行动的，而是用来提出告警和进一步调查。日志更有用的方面是对故障的事后分析和检测不明显的错误。&lt;/p&gt;
&lt;p&gt;除了记录到标准流中，将退出容器的原因记录到/dev/termination-log也是一个好的做法。这个位置是容器在永久消失之前陈述其最后意愿的地方。图1-1显示了容器如何与运行时平台通信的可能选项。
&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1gm1a8dibrjj30ah03dwel.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;容器通过将其视为黑盒，为包装和运行应用程序提供了一种统一的方式。然而，任何旨在成为云原生产品的容器都必须为运行时环境提供API，以观察容器的健康状况并采取相应行动。这种支持是以统一的方式实现容器更新和生命周期自动化的基本前提，从而提高系统的弹性和用户体验。在实际操作中，这意味着，作为最起码的要求，你的容器化应用程序必须为不同类型的健康检查（liveness和readiness）提供API。&lt;/p&gt;
&lt;p&gt;即使是表现更好的应用程序也必须提供其他手段，让管理平台通过集成跟踪和度量收集库（如OpenTracing或Prometheus）来观察容器化应用程序的状态。把你的应用当作一个黑盒子，但要实现所有必要的API，以帮助平台以最好的方式观察和管理你的应用。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K8s中声明式的部署设计模式</title>
      <link>https://kubesphereio.com/post/declarative-deployment/</link>
      <pubDate>Sun, 27 Dec 2020 19:08:06 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/declarative-deployment/</guid>
      <description>&lt;p&gt;声明式Deployment模式的核心是Kubernetes 的Deployment资源。这个抽象封装了一组容器的升级和回滚过程，并使其执行成为一种可重复和自动化的活动。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;我们可以以自助服务的方式将隔离的环境作为命名空间进行调配，并通过调度器将服务调度在这些环境中，只需最少的人工干预。但是随着微服务的数量越来越多，不断地用新的版本更新和更换也成了越来越大的负担。&lt;/p&gt;
&lt;p&gt;将服务升级到下一个版本涉及的活动包括启动新版本的Pod，优雅地停止旧版本的Pod，等待并验证它已经成功启动，有时在失败的情况下将其全部回滚到以前的版本。这些活动的执行方式有两种，一种是允许有一定的停机时间，但不允许同时运行并发的服务版本，另一种是没有停机时间，但在更新过程中由于两个版本的服务都在运行，导致资源使用量增加。手动执行这些步骤可能会导致人为错误，而正确地编写脚本则需要花费大量的精力，这两点都会使发布过程迅速变成瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;幸运的是，Kubernetes也已经自动完成了这项活动。使用Deployment的概念，我们可以描述我们的应用程序应该如何更新，使用不同的策略，并调整更新过程的各个方面。如果您考虑到每次发布周期都要为每个微服务实例进行多次部署的话（根据团队和项目的不同，可能从几分钟到几个月），这是Kubernetes的另一个省力的自动化。&lt;/p&gt;
&lt;p&gt;在第2章中，我们已经看到，为了有效地完成工作，调度器需要主机上有足够的资源、适当的调度策略以及容器充分定义了资源配置文件。同样，为了使部署正确地完成其工作，它希望容器成为良好的云原生。部署的核心是可预测地启动和停止一组Pod的能力。为了达到预期的工作效果，容器本身通常会监听和符合生命周期事件（如SIGTERM；请参见第5章，托管生命周期），并且还提供第4章云原生中所述的健康检查endpoints，即健康探针，以指示它们是否成功启动。&lt;/p&gt;
&lt;p&gt;如果一个容器准确地覆盖了这两个领域，平台就可以干净利落地关闭旧的容器，并通过启动更新的实例来替换它们。然后，更新过程的所有剩余方面都可以以声明的方式定义，并作为一个原子动作执行，具有预定义的步骤和预期的结果。让我们看看容器更新行为的选项吧&lt;/p&gt;
&lt;p&gt;==注意：==&lt;/p&gt;
&lt;h4 id=&#34;使用-kubectl-进行命令式-rolling-updates已被废弃&#34;&gt;使用 kubectl 进行命令式 Rolling Updates已被废弃&lt;/h4&gt;
&lt;p&gt;Kubernetes从一开始就支持滚动更新。最早的实现是势在必行的，客户端kubectl告诉服务器每个更新步骤要做什么。&lt;/p&gt;
&lt;p&gt;虽然kubectl rolling-update 命令仍然存在，但由于这种命令式的方法存在以下缺点，所以它已经被高度废弃。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kubectl rolling-update 不是描述预期的最终状态，而是发布命令让系统进入预期状态。&lt;/li&gt;
&lt;li&gt;替换容器和ReplicationControllers的整个协调逻辑由kubectl执行，它在发生更新过程时，会监控并与API服务器交互，将固有服务器端的责任转移到客户端。&lt;/li&gt;
&lt;li&gt;您可能需要不止一条命令来使系统进入期望状态。这些命令必须是自动的，并且在不同的环境中可以重复使用。&lt;/li&gt;
&lt;li&gt;随着时间的推移，别人可能会覆盖你的修改。&lt;/li&gt;
&lt;li&gt;更新过程必须记录下来，并在服务推进的同时保持更新。&lt;/li&gt;
&lt;li&gt;要想知道我们部署了什么，唯一的方法就是检查系统的状态。有时候，当前系统的状态可能并不是理想的状态，在这种情况下，我们必须使部署文档相互关联。&lt;/li&gt;
&lt;li&gt;取而代之的是，引入Deployment资源对象来支持声明式更新，完全由Kubernetes后端管理。由于声明式更新有如此多的优势，而命令式更新支持终将消失，我们在这个模式中只关注声明式更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rolling-deployment&#34;&gt;Rolling Deployment&lt;/h4&gt;
&lt;p&gt;Kubernetes中更新应用的声明方式是通过Deployment的概念。在幕后，Deployment创建了一个ReplicaSet，支持基于集合的标签选择器。同时，Deployment抽象允许通过RollingUpdate（默认）和Recreate等策略来塑造更新过程行为。例1-1显示了Deployment配置的滚动更新策略重要部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例1-1，Deployment for a rolling update
apiVersion: apps/v1
kind: Deployment
metadata: 
  name: random-generator
spec: 
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
    selector:
      matchLabels:
        app: random-generator
    template:
      metadata:
        labels:
          app: random-generator
      spec: 
        containers:
        - image: k8spatterns/random-generator:1.0
          name: random-generator 
          readinessProbe:
            exec:
              command: [&amp;quot;stat&amp;quot;,&amp;quot;/random-generator-ready&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;滚动更新（RollingUpdate）策略行为确保了更新过程中没有停机时间。在幕后，Deployment实现类似这样的动作来执行，通过创建新的ReplicaSets和用新容器替换旧容器。通过Deployment，这里有一个增强是可以控制新容器滚动的速度。Deployment对象允许你通过maxSurge和maxUnavailable字段来控制可用和超出Pod的范围。图1-1展示了滚动更新过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1glyrd6sisrj30eh04s3z1.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;
&lt;p&gt;要触发声明式更新，你有三个选项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 kubectl replace 将整个部署替换为新版本的部署。&lt;/li&gt;
&lt;li&gt;补丁(kubectl patch)或交互式编辑(kubectl edit)部署，以设置新版本的新容器镜像。&lt;/li&gt;
&lt;li&gt;使用 kubectl set image 来设置部署中的新镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请参阅我们的示例仓库中的完整示例，其中演示了这些命令的用法，并展示了如何使用kubectl rollout监控或回滚升级。&lt;/p&gt;
&lt;p&gt;除了解决前面提到的命令部署服务方式的弊端外，Deployment还带来了以下好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Deployment是一个Kubernetes资源对象，其状态完全由Kubernetes内部管理。整个更新过程在服务器端进行，无需客户端交互。&lt;/li&gt;
&lt;li&gt;Deployment的声明性使您可以看到已部署的状态应该是怎样的，而不是到达那里的必要步骤。&lt;/li&gt;
&lt;li&gt;Deployment定义是一个可执行的对象，在上生产之前会在多个环境中进行测试。&lt;/li&gt;
&lt;li&gt;更新过程也会被完全记录下来，版本上有暂停、继续和回滚到以前版本的选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;fixed-deployment&#34;&gt;Fixed Deployment&lt;/h4&gt;
&lt;p&gt;滚动更新（RollingUpdate）策略对于在更新过程中确保零停机时间非常有用。然而，这种方法的副作用是，在更新过程中，容器的两个版本同时运行。这可能会给服务消费者带来问题，特别是当更新过程在服务API中引入了向后不兼容的变化，而客户端又无法处理这些变化时。对于这种情况，有Recreate策略，如图1-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1glys496y3lj30eg052t9b.jpg&#34; alt=&#34;fixed Deployment.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Recreate策略的效果是将maxUnavailable设置为已声明的复制数。这意味着它首先杀死当前版本的所有容器，然后在旧容器被驱逐时同时启动所有新容器。这意味着它首先杀死当前版本的所有容器，然后在旧容器被驱逐时同时启动所有新容器。这一系列操作的结果是，当所有拥有旧版本的容器被停止时，会有一些停机时间，而且没有新的容器准备好处理传入的请求。从积极的一面来看，不会有两个版本的容器同时运行，简化了服务消费者的生活，一次只处理一个版本。&lt;/p&gt;
&lt;h4 id=&#34;蓝绿发布&#34;&gt;蓝绿发布&lt;/h4&gt;
&lt;p&gt;蓝绿部署是一种用于在最小化停机时间和降低风险的生产环境中部署软件的发布策略。Kubernetes&amp;rsquo;Deployment抽象是一个基本概念，它可以让你定义Kubernetes如何将不可变容器从一个版本过渡到另一个版本。我们可以将Deployment基元作为一个构件，与其他Kubernetes基元一起，实现这种更高级的蓝绿部署的发布策略。&lt;/p&gt;
&lt;p&gt;如果没有使用Service Mesh或Knative等扩展，则需要手动完成蓝绿部署。技术上，它的工作原理是通过创建第二个Deployment，容器的最新版本（我们称它为绿色）还没有服务于任何请求。在这一阶段，原始Deployment中的旧Pod副本（称为蓝色）仍在运行并服务于实时请求。&lt;/p&gt;
&lt;p&gt;一旦我们确信新版本的Pods是健康的，并且准备好处理实时请求，我们就会将流量从旧的Pod副本切换到新的副本。Kubernetes中的这个活动可以通过更新服务选择器来匹配新容器（标记为绿色）来完成。如图1-3所示，一旦绿色容器处理了所有的流量，就可以删除蓝色容器，释放资源用于未来的蓝绿部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1glysteayffj30f105bmxr.jpg&#34; alt=&#34;蓝绿发布.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;蓝绿方式的一个好处是，只有一个版本的应用在服务请求，这降低了Service消费者处理多个并发版本的复杂性。缺点是它需要两倍的应用容量，同时蓝色和绿色容器都在运行。另外，在过渡期间，可能会出现长时间运行的进程和数据库状态漂移的重大并发症。&lt;/p&gt;
&lt;h4 id=&#34;金丝雀发布&#34;&gt;金丝雀发布&lt;/h4&gt;
&lt;p&gt;金丝雀发布是一种通过用新的实例替换一小部分旧的实例来软性地将一个应用程序的新版本部署到生产中的方法。这种技术通过只让部分消费者达到更新的版本来降低将新版本引入生产的风险。当我们对新版本的服务以及它在小样本用户中的表现感到满意时，我们就用新版本替换所有的旧实例。图1-4显示了一个金丝雀版本的运行情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1glyt4zxuo9j30ey0580t8.jpg&#34; alt=&#34;金丝雀发布.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在Kubernetes中，可以通过为新的容器版本（最好使用Deployment）创建一个新的ReplicaSet来实现这一技术，该ReplicaSet的副本数量较少，可以作为Canary实例使用。在这个阶段，服务应该将一些消费者引导到更新的Pod实例上。一旦我们确信使用新 ReplicaSet 的一切都能按预期工作，我们就会将新的 ReplicaSet 规模化，旧的 ReplicaSet 则降为零。从某种程度上来说，我们是在进行一个可控的、经过用户测试的增量式推广。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;Deoloyment本质是 Kubernetes 将手动更新应用程序的繁琐过程转化为可重复和自动化的声明式活动的一个例子。开箱即用的部署策略（rolling和recreate）控制用新容器替换旧容器，而发布策略（bluegreen和金丝雀）则控制新版本如何提供给服务消费者。后两种发布策略是基于人对过渡触发器的决定，因此不是完全自动化的，而是需要人的交互。图1-5显示了部署和发布策略的摘要，显示了过渡期间的实例数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/006bbiLEgy1glyw6xng8fj30d70a1dgn.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个软件都是不同的，部署复杂的系统通常需要额外的步骤和检查。本章讨论的技术涵盖了Pod更新过程，但不包括更新和回滚其他Pod依赖项，如ConfigMaps、Secrete或其他依赖服务。&lt;/p&gt;
&lt;p&gt;截至目前，Kubernetes有一个建议，允许在部署过程中使用钩子。Pre和Post钩子将允许在Kubernetes执行部署策略之前和之后执行自定义命令。这些命令可以在部署进行时执行额外的操作，另外还可以中止、重试或继续部署。这些命令是向新的自动化部署和发布策略迈出的良好一步。目前，一种行之有效的方法是用脚本化去更高层次上编写更新过程，本节中讨论的Deployment和其他属性来管理服务及其依赖关系的更新过程。&lt;/p&gt;
&lt;p&gt;无论你使用何种部署策略，Kubernetes都必须知道你的应用Pod何时启动并运行，以执行所需的步骤序列达到定义的目标部署状态。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>K8s中可预测的需求设计模式</title>
      <link>https://kubesphereio.com/post/predictable-demands/</link>
      <pubDate>Sat, 26 Dec 2020 15:38:59 +0800</pubDate>
      
      <guid>https://kubesphereio.com/post/predictable-demands/</guid>
      <description>&lt;p&gt;在共享云环境中成功部署、管理和共存应用的基础，取决于识别和声明应用资源需求和运行时依赖性。这个Predictable Demands模式是关于你应该如何声明应用需求，无论是硬性的运行时依赖还是资源需求。声明你的需求对于Kubernetes在集群中为你的应用找到合适的位置至关重要。&lt;/p&gt;
&lt;h2 id=&#34;存在问题&#34;&gt;存在问题&lt;/h2&gt;
&lt;p&gt;Kubernetes可以管理用不同编程语言编写的应用，只要该应用可以在容器中运行。然而，不同的语言有不同的资源需求。通常情况下，编译后的语言运行速度更快，而且经常是
与即时运行时或解释语言相比，需要更少的内存。考虑到很多同类别的现代编程语言对资源的要求都差不多，从资源消耗的角度来看，更重要的是领域、应用的业务逻辑和实际实现细节。&lt;/p&gt;
&lt;p&gt;很难预测容器可能需要多少资源才能发挥最佳功能，而知道服务运行的预期资源是开发人员（通过测试发现）。有些服务的CPU和内存消耗情况是固定的，有些服务则是瞬间的。有些服务需要持久性存储来存储数据；有些传统服务需要在主机上固定端口号才能正常工作。定义所有这些应用特性并将其传递给管理平台是云原生应用的基本前提。&lt;/p&gt;
&lt;p&gt;除了资源需求外，应用运行时还对平台管理的能力有依赖性，如数据存储或应用配置。&lt;/p&gt;
&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;了解容器的运行时要求很重要，主要有两个原因。首先，在定义了所有的运行时依赖和资源需求设想后，Kubernetes可以智能地决定在集群上的哪里运行容器以获得最有效的硬件利用率。在大量优先级不同的进程共享资源的环境中，要想成功共存，唯一的办法就是提前了解每个进程的需求。然而，智能投放只是硬币的一面。&lt;/p&gt;
&lt;p&gt;容器资源配置文件必不可少的第二个原因是容量规划。根据具体的服务需求和服务总量，我们可以针对不同的环境做一些容量规划，得出性价比最高的主机配置文件，来满足整个集群的需求。服务资源配置文件和容量规划相辅相成，才能长期成功地进行集群管理。&lt;/p&gt;
&lt;p&gt;在深入研究资源配置文件之前，我们先来看看如何声明运行时依赖关系。&lt;/p&gt;
&lt;h4 id=&#34;运行时依赖&#34;&gt;运行时依赖&lt;/h4&gt;
&lt;p&gt;最常见的运行时依赖之一是用于保存应用程序状态的文件存储。容器文件系统是短暂的，当容器关闭时就会丢失。Kubernetes提供了volume作为Pod级的存储实用程序，可以在容器重启后幸存。&lt;/p&gt;
&lt;p&gt;最直接的卷类型是emptyDir，只要Pod存活，它就会存活，当Pod被删除时，它的内容也会丢失。卷需要有其他类型的存储机制支持，才能有一个在Pod重启后仍能存活的卷。如果你的应用程序需要向这种长时间的存储设备读写文件，你必须在容器定义中使用volumes明确声明这种依赖性。
如例1-1所示。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如例1-1，依赖于PV
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    volumeMounts:
    - mountPath:&amp;quot;/logs&amp;quot;
      name: log-volume
  volumes:
  - name: log-volume
    persistentVolumeClaim:
      claimName: random-generator-log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调度器会评估Pod所需要的卷类型，这将影响Pod的调度位置。如果Pod需要的卷不是由集群上的任何节点提供的，那么Pod根本不会被调度。卷是运行时依赖性的一个例子，它影响Pod可以运行什么样的基础设施，以及Pod是否可以被调度。&lt;/p&gt;
&lt;p&gt;当你要求Kubernetes通过hostPort方式暴露容器端口为主机上特定端口时，也会发生类似的依赖关系。hostPort的使用在节点上创建了另一个运行时依赖性，并限制了Pod的调度位置。 hostPort在集群中的每个节点上保留了端口，并限制每个节点最多调度一个Pod。由于端口冲突，你可以扩展到Kubernetes集群中有多少节点就有多少Pod。&lt;/p&gt;
&lt;p&gt;另一种类型的依赖是配置。几乎每个应用程序都需要一些配置信息，Kubernetes提供的推荐解决方案是通过ConfigMaps。你的服务需要有一个消耗设置的策略&amp;ndash;无论是通过环境变量还是文件系统。无论是哪种情况，这都会引入你的容器对名为ConfigMaps的运行时依赖性。如果没有创建所有预期的 ConfigMaps，则容器被调度在节点上，但它们不会启动。ConfigMaps和Secrets在第19章Configuratio资源中进行了更详细的解释，例1-2展示了如何将这些资源用作运行时依赖。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例1-2所示，依赖于ConfigMap
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    env:
    - name: PATTERN
      valueFrom:
        configMapKeyRef:
          name: random-generator-config
          key: pattern
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与ConfigMaps类似的概念是Secrets，它提供了一种略微更安全的方式将特定环境的配置分发到容器中。使用Secret的方式与使用ConfigMap的方式相同，它引入了从容器到namespace的相同依赖性。&lt;/p&gt;
&lt;p&gt;虽然ConfigMap和Secret对象的创建是我们必须执行的简单管理任务，但集群节点提供了存储和端口。其中一些依赖性限制了Pod被调度的位置（如果有的话），而其他依赖性则限制了Pod的运行。
可能会阻止Pod的启动。在设计带有这种依赖关系的容器化应用程序时，一定要考虑它们创建之后运行时的约束。&lt;/p&gt;
&lt;h4 id=&#34;资源配置文件&#34;&gt;资源配置文件&lt;/h4&gt;
&lt;p&gt;指定容器的依赖性，如ConfigMap、Secret和卷，是很直接的。我们需要更多的思考和实验来确定容器的资源需求。在Kubernetes的上下文中，计算资源被定义为可以被容器请求、分配给容器并从容器中获取的东西。资源分为可压缩的（即可以节制的，如CPU，或网络带宽）和不可压缩的（即不能节制的，如内存）。&lt;/p&gt;
&lt;p&gt;区分可压缩资源和不可压缩资源很重要。如果你的容器消耗了太多的可压缩资源（如CPU），它们就会被节流，但如果它们使用了太多的不可压缩资源（如内存），它们就会被杀死（因为没有其他方法可以要求应用程序释放分配的内存）。&lt;/p&gt;
&lt;p&gt;根据你的应用程序的性质和实现细节，你必须指定所需资源的最小量（称为请求）和它可以增长到的最大量（限制）。每个容器定义都可以以请求和限制的形式指定它所需要的CPU和内存量。在一个高层次上，请求/限制的概念类似于软/硬限制。例如，同样地，我们通过使用-Xms和-Xmx命令行选项来定义Java应用程序的堆大小。&lt;/p&gt;
&lt;p&gt;调度器将Pod调度到节点时，使用的是请求量（但不是限制）。对于一个给定的Pod，调度器只考虑那些仍有足够能力容纳Pod及其所有请求资源量相加容器的节点。从这个意义上说，每个容器的请求字段会影响到Pod可以被调度或不被调度的位置。例1-3显示了如何为Pod指定这种限制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例1-3，资源限制
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec: 
  containers: 
  - image: k8spatterns/random-generator:1.0   name: random-generator 
    resources:
      requests:  
        cpu: 100m 
        memory: 100Mi 
      limits:  
        cpu: 200m 
        memory: 200Mi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据您是指定请求、限制，还是两者都指定，平台提供不同的服务质量（QoS）。&lt;/p&gt;
&lt;h5 id=&#34;best-effort&#34;&gt;Best-Effort&lt;/h5&gt;
&lt;p&gt;没有为其容器设置任何请求和限制的Pod。这样的Pod被认为是最低优先级的，当Pod的节点用完不可压缩资源时，会首先被干掉。&lt;/p&gt;
&lt;h5 id=&#34;burstable&#34;&gt;Burstable&lt;/h5&gt;
&lt;p&gt;已定义请求和限制的Pod，但它们并不相等（而且限制比预期的请求大）。这样的Pod有最小的资源保证，但也愿意在可用的情况下消耗更多的资源，直至其极限。当节点面临不可压缩的资源压力时，如果没有Best-Effort Pods剩余，这些Pod很可能被干掉。&lt;/p&gt;
&lt;h5 id=&#34;guaranteed&#34;&gt;Guaranteed&lt;/h5&gt;
&lt;p&gt;拥有同等数量请求和限制资源的Pod。这些是优先级最高的Pod，保证不会在Best-Effort和Burstable Pods之前被干掉。&lt;/p&gt;
&lt;p&gt;所以你为容器定义的资源特性或省略资源特性会直接影响到它的QoS，并定义了Pod在资源不足时的相对重要性。在定义你的Pod资源需求时，要考虑到这个后果。&lt;/p&gt;
&lt;h4 id=&#34;pod优先级&#34;&gt;Pod优先级&lt;/h4&gt;
&lt;p&gt;我们解释了容器资源声明如何也定义了Pod的QoS，并影响Kubelet在资源不足时干掉Pod中容器的顺序。另一个相关的功能，在写这篇文章的时候还在测试阶段，就是Pod优先和优先权。Pod优先级允许表明一个Pod相对于其他Pod的重要性，这影响了Pod的调度顺序。让我们在例子1-4中看到它的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例1-4，pod优先级
apiVersion: scheduling.k8s.io/v1beta1
kind: PriorityClass
metadata: 
  name: high-priority 
value: 1000 
globalDefault: false
description: This is a very high priority Pod class
---
apiVersion: v1
kind: Pod
metadata: 
  name: random-generator 
  labels: 
    env: random-generator
spec: 
  containers: 
  - image: k8spatterns/random-generator:1.0 
    name: random-generator   
  priorityClassName: high-priority
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们创建了一个PriorityClass，这是一个非命名空间的对象，用于定义一个基于整数的优先级。我们的PriorityClass被命名为high-priority，优先级为1,000。现在我们可以通过它的名字将这个优先级分配给Pods，如priorityClassName：high-riority。PriorityClass是一种表示Pods相对重要性的机制，数值越高表示Pods越重要。&lt;/p&gt;
&lt;p&gt;启用Pod Priority功能后，它会影响调度器将Pod调度在节点上的顺序。首先，优先权进入许可控制器使用priorityClass Name字段来填充新Pod的优先权值。当有多个Pod等待调度时，调度器按最高优先级对待放Pod队列进行排序。在调度队列中，任何待定的Pod都会被选在其他优先级较低的待定Pod之前，如果没有阻止其调度的约束条件，该Pod就会被调度。&lt;/p&gt;
&lt;p&gt;下面是关键部分。如果没有足够容量的节点来调度Pod，调度器可以从节点上抢占（移除）优先级较低的Pod，以释放资源，调度优先级较高的Pod。因此，如果满足其他所有调度要求，优先级较高的Pod可能比优先级较低的Pod更早被调度。这种算法有效地使集群管理员能够控制哪些Pod是更关键的工作负载，并通过允许调度器驱逐优先级较低的Pod，以便在工作节点上为优先级较高的Pod腾出空间，将它们放在第一位。如果一个Pod不能被调度，调度器就会继续调度其他优先级较低的Pod。&lt;/p&gt;
&lt;p&gt;Pod QoS（前面已经讨论过了）和Pod优先级是两个正交的特性，它们之间没有联系，只有一点点重叠。QoS主要被Kubelet用来在可用计算资源较少时保持节点稳定性。==Kubelet在驱逐前首先考虑QoS，然后考虑Pods的PriorityClass。另一方面，调度器驱逐逻辑在选择抢占目标时完全忽略了Pods的QoS==。调度器试图挑选一组优先级最低的Pod，满足优先级较高的Pod等待调度的需求。&lt;/p&gt;
&lt;p&gt;当Pod具有指定的优先级时，它可能会对其他被驱逐的Pod产生不良影响。例如，当一个Pod的优雅终止策略受到重视，第10章中讨论的PodDisruptionBudget，单服务没有得到保证，这可能会打破一个依赖多数Pod数的较低优先级集群应用。&lt;/p&gt;
&lt;p&gt;另一个问题是恶意或不知情的用户创建了优先级最高的Pods，并驱逐了所有其他Pods。为了防止这种情况发生，ResourceQuota已经扩展到支持PriorityClass，较大的优先级数字被保留给通常不应该被抢占或驱逐的关键系统Pods。&lt;/p&gt;
&lt;p&gt;总而言之，Pod优先级应谨慎使用，因为用户指定的数字优先级，指导调度器和Kubelet调度或干掉哪些Pod，会受到用户的影响。任何改变都可能影响许多Pod，并可能阻止平台提供可预测的服务级别协议。&lt;/p&gt;
&lt;h4 id=&#34;项目资源&#34;&gt;项目资源&lt;/h4&gt;
&lt;p&gt;Kubernetes是一个自助服务平台，开发者可以在指定的隔离环境上运行他们认为合适的应用。然而，在一个共享的多租户平台中工作，也需要存在特定的边界和控制单元，以防止一些用户消耗平台的所有资源。其中一个这样的工具是ResourceQuota，它为限制命名空间中的聚合资源消耗提供了约束。通过ResourceQuotas，集群管理员可以限制消耗的计算资源（CPU、内存）和存储的总和。它还可以限制命名空间中创建的对象（如ConfigMaps、Secrets、Pods或Services）的总数。&lt;/p&gt;
&lt;p&gt;这方面的另一个有用的工具是LimitRange，它允许为每种类型的资源设置资源使用限制。除了指定不同资源类型的最小和最大允许量以及这些资源的默认值外，还可以控制请求和限制之间的比例，也就是所谓的超额承诺水平。表1-1给出了如何选择请求和限额的可能值的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;表1-1. Limit和request ranges
Type       Resource  Min    Max  Default limit  Default request  Lim/req ratio  
Container  CPU       500m   2    500m           250m             4
Container  Memory    250Mi  2Gi  500Mi          250Mi            4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LimitRanges对于控制容器资源配置非常有用，这样就不会出现需要的资源超过集群节点所能提供的资源的容器。它还可以防止集群用户创建消耗大量资源的容器，使节点不能为其他容器分配资源。考虑到请求(而不是限制)是调度器用来调度的主要容器特性，LimitRequestRatio允许你控制容器的请求和限制之间的差距有多大。在请求和限制之间有很大的综合差距，会增加节点上超负荷的机会，并且当许多容器同时需要比最初请求更多的资源时，可能会降低应用性能。&lt;/p&gt;
&lt;h4 id=&#34;容量规划&#34;&gt;容量规划&lt;/h4&gt;
&lt;p&gt;考虑到容器在不同的环境中可能会有不同的资源情况，以及不同数量的实例，显然，多用途环境的容量规划并不简单。例如，为了获得最佳的硬件利用率，在一个非生产集群上，你可能主要拥有Best-Effort和Burstable容器。在这样的动态环境中，很多容器都是同时启动和关闭的，即使有容器在资源不足的时候被平台干掉，也不会致命。在生产集群上，我们希望事情更加稳定和可预测，容器可能主要是Guaranteed类型，还有一些Burstable。如果一个容器被杀死，那很可能是一个信号，说明集群的容量应该增加。&lt;/p&gt;
&lt;p&gt;当然，在现实生活中，你使用Kubernetes这样的平台，更可能的原因是还有很多服务需要管理，有些服务即将退出，有些服务还在设计开发阶段。即使是一个不断移动的目标，根据前面描述的类似方法，我们可以计算出每个环境中所有服务所需要的资源总量。&lt;/p&gt;
&lt;h2 id=&#34;讨论&#34;&gt;讨论&lt;/h2&gt;
&lt;p&gt;容器不仅对隔离进程和作为打包方式有用。在确定了资源概况后，它们也是成功进行产能规划的基石。进行一些早期测试，以发现每个容器的资源需求，并将该信息作为未来产能规划和预测的基础。&lt;/p&gt;
&lt;p&gt;然而，更重要的是，资源配置文件是应用程序与Kubernetes沟通的方式，以协助调度和管理决策。如果你的应用不提供任何请求或限制，Kubernetes能做的就是把你的容器当作不透明的盒子，当集群满了的时候就会丢掉。所以，每一个应用或多或少都要考虑和提供这些资源声明。&lt;/p&gt;
&lt;p&gt;现在你已经知道了如何确定我们应用的大小，在第3章 &amp;ldquo;声明式部署 &amp;ldquo;中，你将学习多种策略来让我们的应用在Kubernetes上安装和更新。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>